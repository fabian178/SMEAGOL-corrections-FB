<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>smeagol.models API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>smeagol.models</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow.keras import Model
from tensorflow.keras.layers import Conv1D, Input, Concatenate, Embedding, Reshape, ZeroPadding1D
from .encode import one_hot_dict, base_one_hot, integer_encode

os.environ[&#39;TF_CPP_MIN_LOG_LEVEL&#39;] = &#39;2&#39;


# Define convolutional model

class PWMModel:
    &#34;&#34;&#34;Class to contain convolutional model.
    
    Args:
        pwm_df (pd.DataFrame): dataframe containing PWM IDs and weights.
    &#34;&#34;&#34;
    def __init__(self, pwm_df):
        # Store information
        self.Matrix_ids = np.array(pwm_df.Matrix_id)
        self.widths = np.array(pwm_df.weights.apply(lambda x:x.shape[0]))
        self.max_scores = np.array(pwm_df.weights.apply(lambda x:np.max(x, axis=1).sum()))
        self.channels = len(pwm_df)
        self.max_width = max(self.widths)
        self.define_model()
        self.set_model_weights(pwm_df.weights)
    def define_model(self):
        &#34;&#34;&#34;Define the conv model
        &#34;&#34;&#34;
        input_seq = Input(shape=(None, 1))
        # the padding layer will pad the sequence with zeros
        padding_layer = ZeroPadding1D(padding=(0, self.max_width - 1))
        # the one_hot_layer will one-hot-encode the sequence
        one_hot_layer = Embedding(input_dim=17, output_dim=4, input_length=None)
        reshape_layer_1 = Reshape((-1, 4))
        # the conv_layer will scan the sequence with PWMs
        conv_layer_1 = Conv1D(self.channels, [self.max_width], padding=&#34;valid&#34;, use_bias=False)
        # Connect the layers
        padded = padding_layer(input_seq)
        one_hot = one_hot_layer(padded)
        reshaped = reshape_layer_1(one_hot)
        output = conv_layer_1(reshaped)
        self.model = Model(inputs=input_seq, outputs=output, name=&#34;pwm_model&#34;)
    def pad_weights(self, weights):
        &#34;&#34;&#34;Function to pad weights with zeros
        &#34;&#34;&#34;
        pad_widths = self.max_width - self.widths
        padding = [((0, pw), (0, 0)) for pw in pad_widths]
        padded_weights = [np.pad(w, p, &#39;constant&#39;, constant_values=0) for w, p in zip(weights, padding)]
        padded_weights = np.array(padded_weights)
        padded_weights = np.stack(padded_weights, axis=2)
        return padded_weights
    def set_model_weights(self, weights):
        &#34;&#34;&#34;Function to fix the weights of the conv model
        &#34;&#34;&#34;
        padded_weights = self.pad_weights(weights)
        self.model.layers[2].set_weights([np.array(base_one_hot)])
        self.model.layers[4].set_weights([padded_weights])
    def predict(self, seqs):
        &#34;&#34;&#34;Scan encoded sequences with the model.
        &#34;&#34;&#34;
        predictions = self.model.predict(tf.convert_to_tensor(seqs, dtype=tf.float32))
        return predictions
    def predict_batch_with_threshold(self, seqs, thresholds, score):
        &#34;&#34;&#34;Scan encoded sequences with the model and threshold the returned values.&#34;&#34;&#34;
        # Inference using convolutional model
        predictions = self.predict(seqs)
        # Threshold predictions
        thresholded = np.where(predictions &gt; thresholds)
        # Trim sites that extend beyond sequence end
        select = thresholded[1] + self.widths[thresholded[2]] &lt;= seqs.shape[1]
        thresholded = tuple(x[select] for x in thresholded)
        # Combine site locations with scores
        if score:
            scores = predictions[thresholded]
        else:
            scores = None
        return thresholded, scores
    def predict_with_threshold(self, seqs, frac_threshold, score=False, seq_batch=0):
        &#34;&#34;&#34;Scan encoded sequences in batches with the model and threshold the returned values.
    
        Args:
            seqs (list or np.array): strings or integer encoded sequences
            frac_threshold (float): fraction of maximum score to use as binding site detection threshold
            score (bool): Output binding site scores as well as positions
            seq_batch (int): number of sequences to scan at a time. If 0, scan all.
        
        Returns:
            thresholded (np.array): positions where the input sequence(s) match the input 
                                PWM(s) with a score above the specified threshold.
            scores (np.array): score for each potential binding site
        
        &#34;&#34;&#34;
        # Get threshold for each PWM
        assert (frac_threshold &gt;= 0) &amp; (frac_threshold &lt;= 1)
        thresholds = frac_threshold * self.max_scores
        # Encode sequences if not encoded
        if type(seqs[0]) == str:
            seqs = np.vstack([integer_encode(seq, rc=False) for seq in seqs])
        # Count sequences
        n_seqs = seqs.shape[0]
        # Batch if needed
        if (n_seqs &gt; 1) &amp; (seq_batch &gt; 0) &amp; (seq_batch &lt; n_seqs):
            seqs = np.vsplit(seqs, range(0, n_seqs, seq_batch)[1:])
            thresholded_list = []
            scores_list = []
            for i, batch in enumerate(seqs):
                thresholded, scores = self.predict_batch_with_threshold(batch, thresholds, score)
                thresholded = (thresholded[0] + (i*seq_batch),
                               thresholded[1],
                               thresholded[2])
                thresholded_list.append(thresholded)
                if score:
                    scores_list.append(scores)
            thresholded = tuple([np.concatenate([x[i] for x in thresholded_list]) for i in range(3)])
            del thresholded_list
            if score:
                scores = np.concatenate(scores_list)
                del scores_list
            else:
                scores = None
        else:
            thresholded, scores = self.predict_batch_with_threshold(seqs, thresholds, score)
        return thresholded, scores</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="smeagol.models.PWMModel"><code class="flex name class">
<span>class <span class="ident">PWMModel</span></span>
<span>(</span><span>pwm_df)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to contain convolutional model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pwm_df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>dataframe containing PWM IDs and weights.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PWMModel:
    &#34;&#34;&#34;Class to contain convolutional model.
    
    Args:
        pwm_df (pd.DataFrame): dataframe containing PWM IDs and weights.
    &#34;&#34;&#34;
    def __init__(self, pwm_df):
        # Store information
        self.Matrix_ids = np.array(pwm_df.Matrix_id)
        self.widths = np.array(pwm_df.weights.apply(lambda x:x.shape[0]))
        self.max_scores = np.array(pwm_df.weights.apply(lambda x:np.max(x, axis=1).sum()))
        self.channels = len(pwm_df)
        self.max_width = max(self.widths)
        self.define_model()
        self.set_model_weights(pwm_df.weights)
    def define_model(self):
        &#34;&#34;&#34;Define the conv model
        &#34;&#34;&#34;
        input_seq = Input(shape=(None, 1))
        # the padding layer will pad the sequence with zeros
        padding_layer = ZeroPadding1D(padding=(0, self.max_width - 1))
        # the one_hot_layer will one-hot-encode the sequence
        one_hot_layer = Embedding(input_dim=17, output_dim=4, input_length=None)
        reshape_layer_1 = Reshape((-1, 4))
        # the conv_layer will scan the sequence with PWMs
        conv_layer_1 = Conv1D(self.channels, [self.max_width], padding=&#34;valid&#34;, use_bias=False)
        # Connect the layers
        padded = padding_layer(input_seq)
        one_hot = one_hot_layer(padded)
        reshaped = reshape_layer_1(one_hot)
        output = conv_layer_1(reshaped)
        self.model = Model(inputs=input_seq, outputs=output, name=&#34;pwm_model&#34;)
    def pad_weights(self, weights):
        &#34;&#34;&#34;Function to pad weights with zeros
        &#34;&#34;&#34;
        pad_widths = self.max_width - self.widths
        padding = [((0, pw), (0, 0)) for pw in pad_widths]
        padded_weights = [np.pad(w, p, &#39;constant&#39;, constant_values=0) for w, p in zip(weights, padding)]
        padded_weights = np.array(padded_weights)
        padded_weights = np.stack(padded_weights, axis=2)
        return padded_weights
    def set_model_weights(self, weights):
        &#34;&#34;&#34;Function to fix the weights of the conv model
        &#34;&#34;&#34;
        padded_weights = self.pad_weights(weights)
        self.model.layers[2].set_weights([np.array(base_one_hot)])
        self.model.layers[4].set_weights([padded_weights])
    def predict(self, seqs):
        &#34;&#34;&#34;Scan encoded sequences with the model.
        &#34;&#34;&#34;
        predictions = self.model.predict(tf.convert_to_tensor(seqs, dtype=tf.float32))
        return predictions
    def predict_batch_with_threshold(self, seqs, thresholds, score):
        &#34;&#34;&#34;Scan encoded sequences with the model and threshold the returned values.&#34;&#34;&#34;
        # Inference using convolutional model
        predictions = self.predict(seqs)
        # Threshold predictions
        thresholded = np.where(predictions &gt; thresholds)
        # Trim sites that extend beyond sequence end
        select = thresholded[1] + self.widths[thresholded[2]] &lt;= seqs.shape[1]
        thresholded = tuple(x[select] for x in thresholded)
        # Combine site locations with scores
        if score:
            scores = predictions[thresholded]
        else:
            scores = None
        return thresholded, scores
    def predict_with_threshold(self, seqs, frac_threshold, score=False, seq_batch=0):
        &#34;&#34;&#34;Scan encoded sequences in batches with the model and threshold the returned values.
    
        Args:
            seqs (list or np.array): strings or integer encoded sequences
            frac_threshold (float): fraction of maximum score to use as binding site detection threshold
            score (bool): Output binding site scores as well as positions
            seq_batch (int): number of sequences to scan at a time. If 0, scan all.
        
        Returns:
            thresholded (np.array): positions where the input sequence(s) match the input 
                                PWM(s) with a score above the specified threshold.
            scores (np.array): score for each potential binding site
        
        &#34;&#34;&#34;
        # Get threshold for each PWM
        assert (frac_threshold &gt;= 0) &amp; (frac_threshold &lt;= 1)
        thresholds = frac_threshold * self.max_scores
        # Encode sequences if not encoded
        if type(seqs[0]) == str:
            seqs = np.vstack([integer_encode(seq, rc=False) for seq in seqs])
        # Count sequences
        n_seqs = seqs.shape[0]
        # Batch if needed
        if (n_seqs &gt; 1) &amp; (seq_batch &gt; 0) &amp; (seq_batch &lt; n_seqs):
            seqs = np.vsplit(seqs, range(0, n_seqs, seq_batch)[1:])
            thresholded_list = []
            scores_list = []
            for i, batch in enumerate(seqs):
                thresholded, scores = self.predict_batch_with_threshold(batch, thresholds, score)
                thresholded = (thresholded[0] + (i*seq_batch),
                               thresholded[1],
                               thresholded[2])
                thresholded_list.append(thresholded)
                if score:
                    scores_list.append(scores)
            thresholded = tuple([np.concatenate([x[i] for x in thresholded_list]) for i in range(3)])
            del thresholded_list
            if score:
                scores = np.concatenate(scores_list)
                del scores_list
            else:
                scores = None
        else:
            thresholded, scores = self.predict_batch_with_threshold(seqs, thresholds, score)
        return thresholded, scores</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="smeagol.models.PWMModel.define_model"><code class="name flex">
<span>def <span class="ident">define_model</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Define the conv model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_model(self):
    &#34;&#34;&#34;Define the conv model
    &#34;&#34;&#34;
    input_seq = Input(shape=(None, 1))
    # the padding layer will pad the sequence with zeros
    padding_layer = ZeroPadding1D(padding=(0, self.max_width - 1))
    # the one_hot_layer will one-hot-encode the sequence
    one_hot_layer = Embedding(input_dim=17, output_dim=4, input_length=None)
    reshape_layer_1 = Reshape((-1, 4))
    # the conv_layer will scan the sequence with PWMs
    conv_layer_1 = Conv1D(self.channels, [self.max_width], padding=&#34;valid&#34;, use_bias=False)
    # Connect the layers
    padded = padding_layer(input_seq)
    one_hot = one_hot_layer(padded)
    reshaped = reshape_layer_1(one_hot)
    output = conv_layer_1(reshaped)
    self.model = Model(inputs=input_seq, outputs=output, name=&#34;pwm_model&#34;)</code></pre>
</details>
</dd>
<dt id="smeagol.models.PWMModel.pad_weights"><code class="name flex">
<span>def <span class="ident">pad_weights</span></span>(<span>self, weights)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to pad weights with zeros</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pad_weights(self, weights):
    &#34;&#34;&#34;Function to pad weights with zeros
    &#34;&#34;&#34;
    pad_widths = self.max_width - self.widths
    padding = [((0, pw), (0, 0)) for pw in pad_widths]
    padded_weights = [np.pad(w, p, &#39;constant&#39;, constant_values=0) for w, p in zip(weights, padding)]
    padded_weights = np.array(padded_weights)
    padded_weights = np.stack(padded_weights, axis=2)
    return padded_weights</code></pre>
</details>
</dd>
<dt id="smeagol.models.PWMModel.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, seqs)</span>
</code></dt>
<dd>
<div class="desc"><p>Scan encoded sequences with the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict(self, seqs):
    &#34;&#34;&#34;Scan encoded sequences with the model.
    &#34;&#34;&#34;
    predictions = self.model.predict(tf.convert_to_tensor(seqs, dtype=tf.float32))
    return predictions</code></pre>
</details>
</dd>
<dt id="smeagol.models.PWMModel.predict_batch_with_threshold"><code class="name flex">
<span>def <span class="ident">predict_batch_with_threshold</span></span>(<span>self, seqs, thresholds, score)</span>
</code></dt>
<dd>
<div class="desc"><p>Scan encoded sequences with the model and threshold the returned values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict_batch_with_threshold(self, seqs, thresholds, score):
    &#34;&#34;&#34;Scan encoded sequences with the model and threshold the returned values.&#34;&#34;&#34;
    # Inference using convolutional model
    predictions = self.predict(seqs)
    # Threshold predictions
    thresholded = np.where(predictions &gt; thresholds)
    # Trim sites that extend beyond sequence end
    select = thresholded[1] + self.widths[thresholded[2]] &lt;= seqs.shape[1]
    thresholded = tuple(x[select] for x in thresholded)
    # Combine site locations with scores
    if score:
        scores = predictions[thresholded]
    else:
        scores = None
    return thresholded, scores</code></pre>
</details>
</dd>
<dt id="smeagol.models.PWMModel.predict_with_threshold"><code class="name flex">
<span>def <span class="ident">predict_with_threshold</span></span>(<span>self, seqs, frac_threshold, score=False, seq_batch=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Scan encoded sequences in batches with the model and threshold the returned values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>seqs</code></strong> :&ensp;<code>list</code> or <code>np.array</code></dt>
<dd>strings or integer encoded sequences</dd>
<dt><strong><code>frac_threshold</code></strong> :&ensp;<code>float</code></dt>
<dd>fraction of maximum score to use as binding site detection threshold</dd>
<dt><strong><code>score</code></strong> :&ensp;<code>bool</code></dt>
<dd>Output binding site scores as well as positions</dd>
<dt><strong><code>seq_batch</code></strong> :&ensp;<code>int</code></dt>
<dd>number of sequences to scan at a time. If 0, scan all.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>thresholded (np.array): positions where the input sequence(s) match the input
PWM(s) with a score above the specified threshold.
scores (np.array): score for each potential binding site</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict_with_threshold(self, seqs, frac_threshold, score=False, seq_batch=0):
    &#34;&#34;&#34;Scan encoded sequences in batches with the model and threshold the returned values.

    Args:
        seqs (list or np.array): strings or integer encoded sequences
        frac_threshold (float): fraction of maximum score to use as binding site detection threshold
        score (bool): Output binding site scores as well as positions
        seq_batch (int): number of sequences to scan at a time. If 0, scan all.
    
    Returns:
        thresholded (np.array): positions where the input sequence(s) match the input 
                            PWM(s) with a score above the specified threshold.
        scores (np.array): score for each potential binding site
    
    &#34;&#34;&#34;
    # Get threshold for each PWM
    assert (frac_threshold &gt;= 0) &amp; (frac_threshold &lt;= 1)
    thresholds = frac_threshold * self.max_scores
    # Encode sequences if not encoded
    if type(seqs[0]) == str:
        seqs = np.vstack([integer_encode(seq, rc=False) for seq in seqs])
    # Count sequences
    n_seqs = seqs.shape[0]
    # Batch if needed
    if (n_seqs &gt; 1) &amp; (seq_batch &gt; 0) &amp; (seq_batch &lt; n_seqs):
        seqs = np.vsplit(seqs, range(0, n_seqs, seq_batch)[1:])
        thresholded_list = []
        scores_list = []
        for i, batch in enumerate(seqs):
            thresholded, scores = self.predict_batch_with_threshold(batch, thresholds, score)
            thresholded = (thresholded[0] + (i*seq_batch),
                           thresholded[1],
                           thresholded[2])
            thresholded_list.append(thresholded)
            if score:
                scores_list.append(scores)
        thresholded = tuple([np.concatenate([x[i] for x in thresholded_list]) for i in range(3)])
        del thresholded_list
        if score:
            scores = np.concatenate(scores_list)
            del scores_list
        else:
            scores = None
    else:
        thresholded, scores = self.predict_batch_with_threshold(seqs, thresholds, score)
    return thresholded, scores</code></pre>
</details>
</dd>
<dt id="smeagol.models.PWMModel.set_model_weights"><code class="name flex">
<span>def <span class="ident">set_model_weights</span></span>(<span>self, weights)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to fix the weights of the conv model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_model_weights(self, weights):
    &#34;&#34;&#34;Function to fix the weights of the conv model
    &#34;&#34;&#34;
    padded_weights = self.pad_weights(weights)
    self.model.layers[2].set_weights([np.array(base_one_hot)])
    self.model.layers[4].set_weights([padded_weights])</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="smeagol" href="index.html">smeagol</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="smeagol.models.PWMModel" href="#smeagol.models.PWMModel">PWMModel</a></code></h4>
<ul class="">
<li><code><a title="smeagol.models.PWMModel.define_model" href="#smeagol.models.PWMModel.define_model">define_model</a></code></li>
<li><code><a title="smeagol.models.PWMModel.pad_weights" href="#smeagol.models.PWMModel.pad_weights">pad_weights</a></code></li>
<li><code><a title="smeagol.models.PWMModel.predict" href="#smeagol.models.PWMModel.predict">predict</a></code></li>
<li><code><a title="smeagol.models.PWMModel.predict_batch_with_threshold" href="#smeagol.models.PWMModel.predict_batch_with_threshold">predict_batch_with_threshold</a></code></li>
<li><code><a title="smeagol.models.PWMModel.predict_with_threshold" href="#smeagol.models.PWMModel.predict_with_threshold">predict_with_threshold</a></code></li>
<li><code><a title="smeagol.models.PWMModel.set_model_weights" href="#smeagol.models.PWMModel.set_model_weights">set_model_weights</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>