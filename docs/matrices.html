<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>smeagol.matrices API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>smeagol.matrices</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># General imports
import numpy as np
import pandas as pd
from itertools import combinations
import warnings

# Stats imports
from sklearn.cluster import AgglomerativeClustering


# Functions to check matrices

def check_ppm(probs, warn=False, eps=1e-2):
    &#34;&#34;&#34;Function to check the validity of a PPM.
    A valid PPM should have all values within the range [0,1], all rows summing to 1 (within a tolerance of eps), and exactly 4 columns.

    Args:
        probs (np.array): Numpy array containing probability values. The array should be 2-dimensional and have 4 columns.

    Raises:
        ValueError: if probs is an invalid PPM.

    &#34;&#34;&#34;
    if (np.min(probs) &lt; (0 - eps)) or (np.max(probs) &gt; (1 + eps)):
        raise ValueError(&#39;Values are not within the range [0,1].&#39;)
    rowsums = np.sum(probs, axis=1)
    for s in rowsums:
        if (s &lt; (1 - eps)) or (s &gt; (1 + eps)):
            if warn:
                warnings.warn(&#39;Rows do not all sum to 1. Check the values.&#39;)
            else:
                raise ValueError(&#39;Rows do not all sum to 1.&#39;)
    if probs.shape[1] != 4:
        raise ValueError(&#39;Input array does not have 4 columns.&#39;)


def check_pfm(freqs, warn=False):
    &#34;&#34;&#34;Function to check the validity of a PFM.
    A valid PFM should have non-negative integer values and exactly 4 columns.

    Args:
        freqs (np.array): Numpy array containing frequency values. The array should be 2-dimensional and have 4 columns.

    Raise:
        ValueError: if freqs is an invalid PFM.
    &#34;&#34;&#34;
    if freqs.shape[1] != 4:
        raise ValueError(&#39;Input array does not have 4 columns.&#39;)
    if np.min(freqs) &lt; 0:
        raise ValueError(&#39;Input array contains values less than 0.&#39;)
    if np.any(freqs % 1 != 0):
        if warn:
            warnings.warn(&#39;Input array contains fractional values.&#39;)
        else:
            raise ValueError(&#39;Input array contains fractional values.&#39;)


def check_pwm(weights):
    &#34;&#34;&#34;Function to check the validity of a PWM.
    A valid PWM should have exactly 4 columns.

    Args:
        weights (np.array): Numpy array containing PWM weights. The array should be 2-dimensional and have 4 columns.

    Raise:
        ValueError: if weights is an invalid PWM.
    &#34;&#34;&#34;
    if weights.shape[1] != 4:
        raise ValueError(&#39;Input array does not have 4 columns.&#39;)


# Functions to calculate matrix properties

def entropy(probs):
    &#34;&#34;&#34;Function to calculate the entropy of a PPM or column of a PPM. Entropy is calculated using the formula `H = -sum(p*log2(p))`.

    Args:
        probs (np.array): Numpy array containing probability values.

    Returns:
        result (float): Entropy value

    &#34;&#34;&#34;
    result = -np.sum(probs*np.log2(probs))
    return result


def position_wise_ic(probs):
    &#34;&#34;&#34;Function to calculate the information content (IC) of each position in a PPM. The IC for a specific position is calculated using the formula: IC = 2 - sum(p*log2(p)), assuming a background probability of 0.25 for each of the 4 bases.
 
    Args:
        probs (np.array): Numpy array containing PPM probability values. 

    Returns:
        result (np.array): Numpy array containing the calculated information content of each column in probs.

    &#34;&#34;&#34;
    check_ppm(probs)
    position_wise_entropy = np.apply_along_axis(entropy, axis=1, arr=probs)
    result = 2 - position_wise_entropy
    return result


# Functions to convert matrix types

def ppm_to_pwm(probs):
    &#34;&#34;&#34;Function to convert a valid PPM into a PWM, using the formula: PWM = log2(PPM/B), where the background probability B is set to 0.25.

    Args:
        probs (np.array): Numpy array containing PPM probability values

    Returns:
        Numpy array containing the PWM. The shape of this array is (L, 4) where L is the PWM length.

    &#34;&#34;&#34;
    check_ppm(probs)
    return np.log2(probs/0.25)


def pfm_to_ppm(freqs, pseudocount=0.1):
    &#34;&#34;&#34;Function to convert a valid PFM into a PPM. The matrix is normalized so that every position sums to 1, thus converting from a matrix of frequencies to a matrix of probabilities. To avoid zeros, a value of pseudocount/4 is first added to each position before normalization.

    Args:
        freqs (np.array): array containing PFM values
        pseudocount (float): pseudocount to add

    Returns:
        Numpy array containing PPM.

    &#34;&#34;&#34;
    check_pfm(freqs, warn=False)
    freqs = freqs + (pseudocount/4)
    return normalize_pm(freqs)


def pwm_to_ppm(weights):
    return np.exp2(weights)/4


# Functions to manipulate matrices

def normalize_pm(pm):
    &#34;&#34;&#34;Function to normalize a position matrix so that all rows sum to 1.

    Args:
        pm (np.array): Numpy array containing probability values

    Return:
        Numpy array with all rows normalized to sum to 1.
    &#34;&#34;&#34;
    return np.array([x / np.sum(x) for x in pm])


def trim_ppm(probs, frac_threshold):
    &#34;&#34;&#34;Function to trim non-informative positions from the ends of a PPM. See `position_wise_ic` for how information content of each position is calculated.

    Args:
        probs (np.array): Numpy array containing PPM probability values
        frac_threshold (float): threshold between 0 and 1. The mean information content of all columns in
                                the matrix will be calculated and any continuous columns in the beginning and start
                                of the matrix that have information content less than frac_threshold * mean IC will
                                be dropped.

    Returns:
        result (np.array): Numpy array containing trimmed PPM.
    &#34;&#34;&#34;
    # Checks
    check_ppm(probs)
    assert (frac_threshold &gt;= 0) and (frac_threshold &lt;= 1)

    # Calculate information content
    pos_ic = position_wise_ic(probs)

    # Identify positions to trim
    to_trim = (pos_ic/np.mean(pos_ic)) &lt; frac_threshold
    positions = list(range(probs.shape[0]))
    assert len(to_trim) == len(positions)

    # Trim from start
    while to_trim[0]:
        positions = positions[1:]
        to_trim = to_trim[1:]

    # Trim from end
    while to_trim[-1]:
        positions = positions[:-1]
        to_trim = to_trim[:-1]

    result = probs[positions,:]
    return result


# Functions to calculate similarity between matrices

def cos_sim(a, b):
    &#34;&#34;&#34;Function to calculate the cosine similarity between two vectors.

    Args:
        a, b (np.array): 1-D arrays.

    Returns:
        result (float): cosine similarity between a and b.

    &#34;&#34;&#34;
    result = (a @ b.T) / (np.linalg.norm(a) * np.linalg.norm(b))
    return result


def matrix_correlation(X, Y):
    &#34;&#34;&#34;Function to calculate the correlation between two equal-sized matrices. The values in each matrix are unrolled into a 1-D array and the Pearson correlation of the two 1-D arrays is returned.

    Args:
        X, Y (np.array): two numpy arrays with same shape

    Returns:
        corr (float): Pearson correlation between X and Y (unrolled into 1-D arrays)

    Raises:
        ValueError: if X and Y do not have equal shapes.

    &#34;&#34;&#34;
    # Check shapes
    if X.shape != Y.shape:
        raise ValueError(&#39;Inputs do not have equal shapes.&#39;)

    # Calculate correlation
    corr = np.corrcoef(np.concatenate(X), np.concatenate(Y))[0,1]

    return corr


def order_pms(X, Y):
    &#34;&#34;&#34;Function to order two matrices by width.

    Inputs:
        X, Y (np.array): two position matrices.

    Returns:
        X, Y (np.array): two position matrices ordered by width, X being smaller.
    &#34;&#34;&#34;
    if len(Y) &lt; len(X):
        X, Y = Y, X
    return X, Y


def align_pms(X, Y, min_overlap=None):
    &#34;&#34;&#34;Function to generate all possible overlaps between two position matrices.

    Inputs:
        X, Y (np.array): two position matrices.
        min_overlap (int): minimum overlap allowed between matrices

    Returns:
        result: tuples containing matrix start and end positions corresponding to each possible alignment of the two matrices.
    &#34;&#34;&#34;

    X, Y = order_pms(X, Y)
    Lx = len(X)
    Ly = len(Y)

    # Set minimum allowed overlap
    if min_overlap is not None:
        assert type(min_overlap) == int
        assert (min_overlap &gt; 0) &amp; (min_overlap &lt;= Lx)
    else:
        min_overlap = min(3, Lx)

    # Identify different possible alignments of the two matrices
    aln_starts = range(min_overlap - Lx, Ly - min_overlap + 1)

    # Identify the aligned portions of the matrices
    X_starts = [max(-i, 0) for i in aln_starts] # if i&lt;0, cut X positions that don&#39;t align to Y
    X_ends = [min(Lx, Ly - i) for i in aln_starts] # trim columns of X that don&#39;t align to Y on the right
    Y_starts = [max(i, 0) for i in aln_starts] # if i&gt;0, cut Y from the left
    Y_ends = [min(Ly, i + Lx) for i in aln_starts] # if i+Lx exceeds Ly, cut alignment at Ly

    X_w = np.unique([e - s for e, s in zip(X_ends, X_starts)])
    Y_w = np.unique([e - s for e, s in zip(Y_ends, Y_starts)])
    assert np.all(X_w == Y_w)
    assert np.all(X_w &gt;= min_overlap)

    result = zip(X_starts, X_ends, Y_starts, Y_ends)
    return result


def ncorr(X, Y, min_overlap=None):
    &#34;&#34;&#34;Function to calculate the normalized Pearson correlation between two position matrices, as defined in doi: 10.1093/nar/gkx314.

    Inputs:
        X, Y (np.array): two position matrices.
        min_overlap (int): minimum overlap allowed between matrices

    Returns:
        result (float): normalized Pearson correlation value
    &#34;&#34;&#34;
    ncorrs = []

    X, Y = order_pms(X, Y)
    alignments = align_pms(X, Y, min_overlap=None)

    for X_start, X_end, Y_start, Y_end in alignments:

        # Get portions of matrices that are aligned
        Y_i = Y[Y_start : Y_end, : ]
        X_i = X[X_start : X_end, :]

        # Calculate the length of the alignment
        w = Y_end - Y_start

        # Calculate the correlation
        corr = matrix_correlation(X_i, Y_i)

        # Normalize the correlation
        W = len(X) + len(Y) - w
        ncorr = corr * w/W
        ncorrs.append(ncorr)

    # Return the highest normalized correlation value across all alignments.
    result = max(ncorrs)
    return result


def pairwise_ncorrs(mats):
    &#34;&#34;&#34;Function to calculate all pairwise normalized Pearson correlations between a list of position matrices.

    Args:
        mats (list): a list of position matrices.

    Returns:
        ncorrs (np.array): All pairwise normalized Pearson correlations between matrices in mats.

    &#34;&#34;&#34;
    # Get all pairwise combinations of matrices
    combins = list(combinations(range(len(mats)), 2))

    # Calculate pairwise similarities between all matrices
    sims = np.zeros(shape=(len(mats), len(mats)))
    for i, j in combins:
        if i != j:
            sims[i, j] = sims[j, i] = ncorr(mats[i], mats[j])

    # Set diagonal values to 1
    for i in range(len(mats)):
        sims[i, i] = 1

    # return
    return sims


# Functions to cluster matrices and choose representatives

def choose_representative_pm(df, sims=None, maximize=&#39;median&#39;, weight_col=&#39;weights&#39;, matrix_type=&#39;PWM&#39;):
    &#34;&#34;&#34;Function to choose a representative position matrix from a group. If 2 matrices are supplied, the one with lower entropy is chosen. For larger sets of matrices, the matrix with the highest mean (or median) normalized Pearson correlation to all other matrices is chosen.

    Args:
        df (pandas df): Dataframe containing position matrix values and IDs. The ID column should be named &#39;Matrix_id&#39;.
        sims (np.array): pairwise similarities between all PWMs in df
        maximize (str): &#39;mean&#39; or &#39;median&#39;. Metric to choose representative matrix.
        weight_col(str): the column in df that contains matrix values.
        matrix_type (str): PPM or PWM

    Returns:
        result (list): IDs for the selected representative matrices.

    &#34;&#34;&#34;
    mats = list(df[weight_col].values)
    ids = list(df.Matrix_id)

    # Get pairwise similarities
    if sims is None:
        sims = pairwise_ncorrs(mats)

    if len(mats)==2:
        # Between two matrices, choose the one with lowest entropy
        if matrix_type == &#39;PPM&#39;:
            entropies = [entropy(mat) for mat in mats]
        elif matrix_type == &#39;PWM&#39;:
            entropies = [entropy(pwm_to_ppm(mat)) for mat in mats]
        else:
            raise ValueError(&#34;matrix_type should be PPM or PWM.&#34;)
        sel_mat = np.argmin(entropies)
    elif len(mats) &gt; 2:
        # Otherwise, choose the matrix closest to other matrices
        if maximize == &#39;mean&#39;:
            sel_mat = np.argmax(np.mean(sims, axis=0))
        elif maximize == &#39;median&#39;:
            sel_mat = np.argmax(np.median(sims, axis=0))
    else:
        sel_mat = 0

    # Final result
    result = ids[sel_mat]
    return result


def choose_cluster_representative_pms(df, sims=None, clusters=None, maximize=&#39;median&#39;,
                                       weight_col=&#39;weights&#39;, matrix_type=&#39;PWM&#39;):
    &#34;&#34;&#34;Function to choose a representative position matrix from each cluster. This performs `choose_representative_pm` to choose a representative matrix within each supplied cluster.

    Args:
        df (pandas df): Dataframe containing position matrix values and IDs.
        sims (np.array): pairwise similarities between all PWMs in pwms
        clusters (list): cluster assignments for each PWM.
        maximize (str): &#39;mean&#39; or &#39;median&#39;. Metric  to choose representative matrix.
        weight_col(str): column in pwms that contains matrix values.
        matrix_type (str): PPM or PWM

    Returns:
        representatives (list): IDs for the selected representative matrices.

    &#34;&#34;&#34;
    representatives = []
    cluster_ids = np.unique(clusters)
    c_sims = None

    # Get pairwise similarities within each cluster
    for cluster_id in cluster_ids:
        in_cluster = (clusters==cluster_id)
        mat_ids = np.array(df.Matrix_id)[in_cluster]
        mats = df[df.Matrix_id.isin(mat_ids)]
        if sims is not None:
            c_sims = sims[in_cluster, :][:, in_cluster]
        # Choose representative matrix within cluster
        sel_mat = choose_representative_pm(mats, sims=c_sims, maximize=maximize,
                                            weight_col=weight_col, matrix_type=matrix_type)
        representatives.append(sel_mat)
    return representatives


def cluster_pms(df, n_clusters, sims=None, weight_col=&#39;weights&#39;):
    &#34;&#34;&#34;Function to cluster position matrices.
    A distance matrix between the matrices is computed using the normalized Pearson correlation metric and agglomerative clustering is used to find clusters. `choose_representative_pm` is called to identify a representative matrix from each cluster.

    Args:
        df (pandas df): Dataframe containing position matrix values and IDs.
        n_clusters (int): Number of clusters
        sims (np.array): pairwise similarities between all matrices in pwms
        weight_col(str): column in pwms that contains matrix values.

    Returns:
        result: dictionary containing cluster labels, representative matrix IDs, and
                minimum pairwise similarity within each cluster

    &#34;&#34;&#34;
    # Get pairwise similarities between PMs
    if sims is None:
        sims = pairwise_ncorrs(list(df[weight_col]))

    # Cluster using agglomerative clustering
    cluster_ids = AgglomerativeClustering(n_clusters=n_clusters, affinity=&#39;precomputed&#39;,
                                          distance_threshold=None, linkage=&#39;complete&#39;).fit(2-sims).labels_

    # Choose representative matrix from each cluster
    reps = choose_cluster_representative_pms(df, sims=sims, clusters=cluster_ids,
                               maximize=&#39;median&#39;, weight_col=weight_col)
    min_ncorrs = [np.min(sims[cluster_ids==i, :][:, cluster_ids==i]) for i in range(n_clusters)]
    result = {&#39;clusters&#39;:cluster_ids, &#39;reps&#39;:reps, &#39;min_ncorr&#39;: min_ncorrs}
    return result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="smeagol.matrices.align_pms"><code class="name flex">
<span>def <span class="ident">align_pms</span></span>(<span>X, Y, min_overlap=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to generate all possible overlaps between two position matrices.</p>
<h2 id="inputs">Inputs</h2>
<p>X, Y (np.array): two position matrices.
min_overlap (int): minimum overlap allowed between matrices</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>result</code></dt>
<dd>tuples containing matrix start and end positions corresponding to each possible alignment of the two matrices.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_pms(X, Y, min_overlap=None):
    &#34;&#34;&#34;Function to generate all possible overlaps between two position matrices.

    Inputs:
        X, Y (np.array): two position matrices.
        min_overlap (int): minimum overlap allowed between matrices

    Returns:
        result: tuples containing matrix start and end positions corresponding to each possible alignment of the two matrices.
    &#34;&#34;&#34;

    X, Y = order_pms(X, Y)
    Lx = len(X)
    Ly = len(Y)

    # Set minimum allowed overlap
    if min_overlap is not None:
        assert type(min_overlap) == int
        assert (min_overlap &gt; 0) &amp; (min_overlap &lt;= Lx)
    else:
        min_overlap = min(3, Lx)

    # Identify different possible alignments of the two matrices
    aln_starts = range(min_overlap - Lx, Ly - min_overlap + 1)

    # Identify the aligned portions of the matrices
    X_starts = [max(-i, 0) for i in aln_starts] # if i&lt;0, cut X positions that don&#39;t align to Y
    X_ends = [min(Lx, Ly - i) for i in aln_starts] # trim columns of X that don&#39;t align to Y on the right
    Y_starts = [max(i, 0) for i in aln_starts] # if i&gt;0, cut Y from the left
    Y_ends = [min(Ly, i + Lx) for i in aln_starts] # if i+Lx exceeds Ly, cut alignment at Ly

    X_w = np.unique([e - s for e, s in zip(X_ends, X_starts)])
    Y_w = np.unique([e - s for e, s in zip(Y_ends, Y_starts)])
    assert np.all(X_w == Y_w)
    assert np.all(X_w &gt;= min_overlap)

    result = zip(X_starts, X_ends, Y_starts, Y_ends)
    return result</code></pre>
</details>
</dd>
<dt id="smeagol.matrices.check_pfm"><code class="name flex">
<span>def <span class="ident">check_pfm</span></span>(<span>freqs, warn=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to check the validity of a PFM.
A valid PFM should have non-negative integer values and exactly 4 columns.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>freqs</code></strong> :&ensp;<code>np.array</code></dt>
<dd>Numpy array containing frequency values. The array should be 2-dimensional and have 4 columns.</dd>
</dl>
<h2 id="raise">Raise</h2>
<p>ValueError: if freqs is an invalid PFM.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_pfm(freqs, warn=False):
    &#34;&#34;&#34;Function to check the validity of a PFM.
    A valid PFM should have non-negative integer values and exactly 4 columns.

    Args:
        freqs (np.array): Numpy array containing frequency values. The array should be 2-dimensional and have 4 columns.

    Raise:
        ValueError: if freqs is an invalid PFM.
    &#34;&#34;&#34;
    if freqs.shape[1] != 4:
        raise ValueError(&#39;Input array does not have 4 columns.&#39;)
    if np.min(freqs) &lt; 0:
        raise ValueError(&#39;Input array contains values less than 0.&#39;)
    if np.any(freqs % 1 != 0):
        if warn:
            warnings.warn(&#39;Input array contains fractional values.&#39;)
        else:
            raise ValueError(&#39;Input array contains fractional values.&#39;)</code></pre>
</details>
</dd>
<dt id="smeagol.matrices.check_ppm"><code class="name flex">
<span>def <span class="ident">check_ppm</span></span>(<span>probs, warn=False, eps=0.01)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to check the validity of a PPM.
A valid PPM should have all values within the range [0,1], all rows summing to 1 (within a tolerance of eps), and exactly 4 columns.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>probs</code></strong> :&ensp;<code>np.array</code></dt>
<dd>Numpy array containing probability values. The array should be 2-dimensional and have 4 columns.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if probs is an invalid PPM.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_ppm(probs, warn=False, eps=1e-2):
    &#34;&#34;&#34;Function to check the validity of a PPM.
    A valid PPM should have all values within the range [0,1], all rows summing to 1 (within a tolerance of eps), and exactly 4 columns.

    Args:
        probs (np.array): Numpy array containing probability values. The array should be 2-dimensional and have 4 columns.

    Raises:
        ValueError: if probs is an invalid PPM.

    &#34;&#34;&#34;
    if (np.min(probs) &lt; (0 - eps)) or (np.max(probs) &gt; (1 + eps)):
        raise ValueError(&#39;Values are not within the range [0,1].&#39;)
    rowsums = np.sum(probs, axis=1)
    for s in rowsums:
        if (s &lt; (1 - eps)) or (s &gt; (1 + eps)):
            if warn:
                warnings.warn(&#39;Rows do not all sum to 1. Check the values.&#39;)
            else:
                raise ValueError(&#39;Rows do not all sum to 1.&#39;)
    if probs.shape[1] != 4:
        raise ValueError(&#39;Input array does not have 4 columns.&#39;)</code></pre>
</details>
</dd>
<dt id="smeagol.matrices.check_pwm"><code class="name flex">
<span>def <span class="ident">check_pwm</span></span>(<span>weights)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to check the validity of a PWM.
A valid PWM should have exactly 4 columns.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>weights</code></strong> :&ensp;<code>np.array</code></dt>
<dd>Numpy array containing PWM weights. The array should be 2-dimensional and have 4 columns.</dd>
</dl>
<h2 id="raise">Raise</h2>
<p>ValueError: if weights is an invalid PWM.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_pwm(weights):
    &#34;&#34;&#34;Function to check the validity of a PWM.
    A valid PWM should have exactly 4 columns.

    Args:
        weights (np.array): Numpy array containing PWM weights. The array should be 2-dimensional and have 4 columns.

    Raise:
        ValueError: if weights is an invalid PWM.
    &#34;&#34;&#34;
    if weights.shape[1] != 4:
        raise ValueError(&#39;Input array does not have 4 columns.&#39;)</code></pre>
</details>
</dd>
<dt id="smeagol.matrices.choose_cluster_representative_pms"><code class="name flex">
<span>def <span class="ident">choose_cluster_representative_pms</span></span>(<span>df, sims=None, clusters=None, maximize='median', weight_col='weights', matrix_type='PWM')</span>
</code></dt>
<dd>
<div class="desc"><p>Function to choose a representative position matrix from each cluster. This performs <code><a title="smeagol.matrices.choose_representative_pm" href="#smeagol.matrices.choose_representative_pm">choose_representative_pm()</a></code> to choose a representative matrix within each supplied cluster.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas df</code></dt>
<dd>Dataframe containing position matrix values and IDs.</dd>
<dt><strong><code>sims</code></strong> :&ensp;<code>np.array</code></dt>
<dd>pairwise similarities between all PWMs in pwms</dd>
<dt><strong><code>clusters</code></strong> :&ensp;<code>list</code></dt>
<dd>cluster assignments for each PWM.</dd>
<dt><strong><code>maximize</code></strong> :&ensp;<code>str</code></dt>
<dd>'mean' or 'median'. Metric
to choose representative matrix.</dd>
<dt>weight_col(str): column in pwms that contains matrix values.</dt>
<dt><strong><code>matrix_type</code></strong> :&ensp;<code>str</code></dt>
<dd>PPM or PWM</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>representatives (list): IDs for the selected representative matrices.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choose_cluster_representative_pms(df, sims=None, clusters=None, maximize=&#39;median&#39;,
                                       weight_col=&#39;weights&#39;, matrix_type=&#39;PWM&#39;):
    &#34;&#34;&#34;Function to choose a representative position matrix from each cluster. This performs `choose_representative_pm` to choose a representative matrix within each supplied cluster.

    Args:
        df (pandas df): Dataframe containing position matrix values and IDs.
        sims (np.array): pairwise similarities between all PWMs in pwms
        clusters (list): cluster assignments for each PWM.
        maximize (str): &#39;mean&#39; or &#39;median&#39;. Metric  to choose representative matrix.
        weight_col(str): column in pwms that contains matrix values.
        matrix_type (str): PPM or PWM

    Returns:
        representatives (list): IDs for the selected representative matrices.

    &#34;&#34;&#34;
    representatives = []
    cluster_ids = np.unique(clusters)
    c_sims = None

    # Get pairwise similarities within each cluster
    for cluster_id in cluster_ids:
        in_cluster = (clusters==cluster_id)
        mat_ids = np.array(df.Matrix_id)[in_cluster]
        mats = df[df.Matrix_id.isin(mat_ids)]
        if sims is not None:
            c_sims = sims[in_cluster, :][:, in_cluster]
        # Choose representative matrix within cluster
        sel_mat = choose_representative_pm(mats, sims=c_sims, maximize=maximize,
                                            weight_col=weight_col, matrix_type=matrix_type)
        representatives.append(sel_mat)
    return representatives</code></pre>
</details>
</dd>
<dt id="smeagol.matrices.choose_representative_pm"><code class="name flex">
<span>def <span class="ident">choose_representative_pm</span></span>(<span>df, sims=None, maximize='median', weight_col='weights', matrix_type='PWM')</span>
</code></dt>
<dd>
<div class="desc"><p>Function to choose a representative position matrix from a group. If 2 matrices are supplied, the one with lower entropy is chosen. For larger sets of matrices, the matrix with the highest mean (or median) normalized Pearson correlation to all other matrices is chosen.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas df</code></dt>
<dd>Dataframe containing position matrix values and IDs. The ID column should be named 'Matrix_id'.</dd>
<dt><strong><code>sims</code></strong> :&ensp;<code>np.array</code></dt>
<dd>pairwise similarities between all PWMs in df</dd>
<dt><strong><code>maximize</code></strong> :&ensp;<code>str</code></dt>
<dd>'mean' or 'median'. Metric to choose representative matrix.</dd>
<dt>weight_col(str): the column in df that contains matrix values.</dt>
<dt><strong><code>matrix_type</code></strong> :&ensp;<code>str</code></dt>
<dd>PPM or PWM</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result (list): IDs for the selected representative matrices.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choose_representative_pm(df, sims=None, maximize=&#39;median&#39;, weight_col=&#39;weights&#39;, matrix_type=&#39;PWM&#39;):
    &#34;&#34;&#34;Function to choose a representative position matrix from a group. If 2 matrices are supplied, the one with lower entropy is chosen. For larger sets of matrices, the matrix with the highest mean (or median) normalized Pearson correlation to all other matrices is chosen.

    Args:
        df (pandas df): Dataframe containing position matrix values and IDs. The ID column should be named &#39;Matrix_id&#39;.
        sims (np.array): pairwise similarities between all PWMs in df
        maximize (str): &#39;mean&#39; or &#39;median&#39;. Metric to choose representative matrix.
        weight_col(str): the column in df that contains matrix values.
        matrix_type (str): PPM or PWM

    Returns:
        result (list): IDs for the selected representative matrices.

    &#34;&#34;&#34;
    mats = list(df[weight_col].values)
    ids = list(df.Matrix_id)

    # Get pairwise similarities
    if sims is None:
        sims = pairwise_ncorrs(mats)

    if len(mats)==2:
        # Between two matrices, choose the one with lowest entropy
        if matrix_type == &#39;PPM&#39;:
            entropies = [entropy(mat) for mat in mats]
        elif matrix_type == &#39;PWM&#39;:
            entropies = [entropy(pwm_to_ppm(mat)) for mat in mats]
        else:
            raise ValueError(&#34;matrix_type should be PPM or PWM.&#34;)
        sel_mat = np.argmin(entropies)
    elif len(mats) &gt; 2:
        # Otherwise, choose the matrix closest to other matrices
        if maximize == &#39;mean&#39;:
            sel_mat = np.argmax(np.mean(sims, axis=0))
        elif maximize == &#39;median&#39;:
            sel_mat = np.argmax(np.median(sims, axis=0))
    else:
        sel_mat = 0

    # Final result
    result = ids[sel_mat]
    return result</code></pre>
</details>
</dd>
<dt id="smeagol.matrices.cluster_pms"><code class="name flex">
<span>def <span class="ident">cluster_pms</span></span>(<span>df, n_clusters, sims=None, weight_col='weights')</span>
</code></dt>
<dd>
<div class="desc"><p>Function to cluster position matrices.
A distance matrix between the matrices is computed using the normalized Pearson correlation metric and agglomerative clustering is used to find clusters. <code><a title="smeagol.matrices.choose_representative_pm" href="#smeagol.matrices.choose_representative_pm">choose_representative_pm()</a></code> is called to identify a representative matrix from each cluster.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas df</code></dt>
<dd>Dataframe containing position matrix values and IDs.</dd>
<dt><strong><code>n_clusters</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of clusters</dd>
<dt><strong><code>sims</code></strong> :&ensp;<code>np.array</code></dt>
<dd>pairwise similarities between all matrices in pwms</dd>
</dl>
<p>weight_col(str): column in pwms that contains matrix values.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>result</code></dt>
<dd>dictionary containing cluster labels, representative matrix IDs, and
minimum pairwise similarity within each cluster</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cluster_pms(df, n_clusters, sims=None, weight_col=&#39;weights&#39;):
    &#34;&#34;&#34;Function to cluster position matrices.
    A distance matrix between the matrices is computed using the normalized Pearson correlation metric and agglomerative clustering is used to find clusters. `choose_representative_pm` is called to identify a representative matrix from each cluster.

    Args:
        df (pandas df): Dataframe containing position matrix values and IDs.
        n_clusters (int): Number of clusters
        sims (np.array): pairwise similarities between all matrices in pwms
        weight_col(str): column in pwms that contains matrix values.

    Returns:
        result: dictionary containing cluster labels, representative matrix IDs, and
                minimum pairwise similarity within each cluster

    &#34;&#34;&#34;
    # Get pairwise similarities between PMs
    if sims is None:
        sims = pairwise_ncorrs(list(df[weight_col]))

    # Cluster using agglomerative clustering
    cluster_ids = AgglomerativeClustering(n_clusters=n_clusters, affinity=&#39;precomputed&#39;,
                                          distance_threshold=None, linkage=&#39;complete&#39;).fit(2-sims).labels_

    # Choose representative matrix from each cluster
    reps = choose_cluster_representative_pms(df, sims=sims, clusters=cluster_ids,
                               maximize=&#39;median&#39;, weight_col=weight_col)
    min_ncorrs = [np.min(sims[cluster_ids==i, :][:, cluster_ids==i]) for i in range(n_clusters)]
    result = {&#39;clusters&#39;:cluster_ids, &#39;reps&#39;:reps, &#39;min_ncorr&#39;: min_ncorrs}
    return result</code></pre>
</details>
</dd>
<dt id="smeagol.matrices.cos_sim"><code class="name flex">
<span>def <span class="ident">cos_sim</span></span>(<span>a, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to calculate the cosine similarity between two vectors.</p>
<h2 id="args">Args</h2>
<p>a, b (np.array): 1-D arrays.</p>
<h2 id="returns">Returns</h2>
<p>result (float): cosine similarity between a and b.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cos_sim(a, b):
    &#34;&#34;&#34;Function to calculate the cosine similarity between two vectors.

    Args:
        a, b (np.array): 1-D arrays.

    Returns:
        result (float): cosine similarity between a and b.

    &#34;&#34;&#34;
    result = (a @ b.T) / (np.linalg.norm(a) * np.linalg.norm(b))
    return result</code></pre>
</details>
</dd>
<dt id="smeagol.matrices.entropy"><code class="name flex">
<span>def <span class="ident">entropy</span></span>(<span>probs)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to calculate the entropy of a PPM or column of a PPM. Entropy is calculated using the formula <code>H = -sum(p*log2(p))</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>probs</code></strong> :&ensp;<code>np.array</code></dt>
<dd>Numpy array containing probability values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result (float): Entropy value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def entropy(probs):
    &#34;&#34;&#34;Function to calculate the entropy of a PPM or column of a PPM. Entropy is calculated using the formula `H = -sum(p*log2(p))`.

    Args:
        probs (np.array): Numpy array containing probability values.

    Returns:
        result (float): Entropy value

    &#34;&#34;&#34;
    result = -np.sum(probs*np.log2(probs))
    return result</code></pre>
</details>
</dd>
<dt id="smeagol.matrices.matrix_correlation"><code class="name flex">
<span>def <span class="ident">matrix_correlation</span></span>(<span>X, Y)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to calculate the correlation between two equal-sized matrices. The values in each matrix are unrolled into a 1-D array and the Pearson correlation of the two 1-D arrays is returned.</p>
<h2 id="args">Args</h2>
<p>X, Y (np.array): two numpy arrays with same shape</p>
<h2 id="returns">Returns</h2>
<p>corr (float): Pearson correlation between X and Y (unrolled into 1-D arrays)</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if X and Y do not have equal shapes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matrix_correlation(X, Y):
    &#34;&#34;&#34;Function to calculate the correlation between two equal-sized matrices. The values in each matrix are unrolled into a 1-D array and the Pearson correlation of the two 1-D arrays is returned.

    Args:
        X, Y (np.array): two numpy arrays with same shape

    Returns:
        corr (float): Pearson correlation between X and Y (unrolled into 1-D arrays)

    Raises:
        ValueError: if X and Y do not have equal shapes.

    &#34;&#34;&#34;
    # Check shapes
    if X.shape != Y.shape:
        raise ValueError(&#39;Inputs do not have equal shapes.&#39;)

    # Calculate correlation
    corr = np.corrcoef(np.concatenate(X), np.concatenate(Y))[0,1]

    return corr</code></pre>
</details>
</dd>
<dt id="smeagol.matrices.ncorr"><code class="name flex">
<span>def <span class="ident">ncorr</span></span>(<span>X, Y, min_overlap=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to calculate the normalized Pearson correlation between two position matrices, as defined in doi: 10.1093/nar/gkx314.</p>
<h2 id="inputs">Inputs</h2>
<p>X, Y (np.array): two position matrices.
min_overlap (int): minimum overlap allowed between matrices</p>
<h2 id="returns">Returns</h2>
<p>result (float): normalized Pearson correlation value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ncorr(X, Y, min_overlap=None):
    &#34;&#34;&#34;Function to calculate the normalized Pearson correlation between two position matrices, as defined in doi: 10.1093/nar/gkx314.

    Inputs:
        X, Y (np.array): two position matrices.
        min_overlap (int): minimum overlap allowed between matrices

    Returns:
        result (float): normalized Pearson correlation value
    &#34;&#34;&#34;
    ncorrs = []

    X, Y = order_pms(X, Y)
    alignments = align_pms(X, Y, min_overlap=None)

    for X_start, X_end, Y_start, Y_end in alignments:

        # Get portions of matrices that are aligned
        Y_i = Y[Y_start : Y_end, : ]
        X_i = X[X_start : X_end, :]

        # Calculate the length of the alignment
        w = Y_end - Y_start

        # Calculate the correlation
        corr = matrix_correlation(X_i, Y_i)

        # Normalize the correlation
        W = len(X) + len(Y) - w
        ncorr = corr * w/W
        ncorrs.append(ncorr)

    # Return the highest normalized correlation value across all alignments.
    result = max(ncorrs)
    return result</code></pre>
</details>
</dd>
<dt id="smeagol.matrices.normalize_pm"><code class="name flex">
<span>def <span class="ident">normalize_pm</span></span>(<span>pm)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to normalize a position matrix so that all rows sum to 1.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pm</code></strong> :&ensp;<code>np.array</code></dt>
<dd>Numpy array containing probability values</dd>
</dl>
<h2 id="return">Return</h2>
<p>Numpy array with all rows normalized to sum to 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_pm(pm):
    &#34;&#34;&#34;Function to normalize a position matrix so that all rows sum to 1.

    Args:
        pm (np.array): Numpy array containing probability values

    Return:
        Numpy array with all rows normalized to sum to 1.
    &#34;&#34;&#34;
    return np.array([x / np.sum(x) for x in pm])</code></pre>
</details>
</dd>
<dt id="smeagol.matrices.order_pms"><code class="name flex">
<span>def <span class="ident">order_pms</span></span>(<span>X, Y)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to order two matrices by width.</p>
<h2 id="inputs">Inputs</h2>
<p>X, Y (np.array): two position matrices.</p>
<h2 id="returns">Returns</h2>
<p>X, Y (np.array): two position matrices ordered by width, X being smaller.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order_pms(X, Y):
    &#34;&#34;&#34;Function to order two matrices by width.

    Inputs:
        X, Y (np.array): two position matrices.

    Returns:
        X, Y (np.array): two position matrices ordered by width, X being smaller.
    &#34;&#34;&#34;
    if len(Y) &lt; len(X):
        X, Y = Y, X
    return X, Y</code></pre>
</details>
</dd>
<dt id="smeagol.matrices.pairwise_ncorrs"><code class="name flex">
<span>def <span class="ident">pairwise_ncorrs</span></span>(<span>mats)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to calculate all pairwise normalized Pearson correlations between a list of position matrices.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mats</code></strong> :&ensp;<code>list</code></dt>
<dd>a list of position matrices.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ncorrs (np.array): All pairwise normalized Pearson correlations between matrices in mats.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pairwise_ncorrs(mats):
    &#34;&#34;&#34;Function to calculate all pairwise normalized Pearson correlations between a list of position matrices.

    Args:
        mats (list): a list of position matrices.

    Returns:
        ncorrs (np.array): All pairwise normalized Pearson correlations between matrices in mats.

    &#34;&#34;&#34;
    # Get all pairwise combinations of matrices
    combins = list(combinations(range(len(mats)), 2))

    # Calculate pairwise similarities between all matrices
    sims = np.zeros(shape=(len(mats), len(mats)))
    for i, j in combins:
        if i != j:
            sims[i, j] = sims[j, i] = ncorr(mats[i], mats[j])

    # Set diagonal values to 1
    for i in range(len(mats)):
        sims[i, i] = 1

    # return
    return sims</code></pre>
</details>
</dd>
<dt id="smeagol.matrices.pfm_to_ppm"><code class="name flex">
<span>def <span class="ident">pfm_to_ppm</span></span>(<span>freqs, pseudocount=0.1)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to convert a valid PFM into a PPM. The matrix is normalized so that every position sums to 1, thus converting from a matrix of frequencies to a matrix of probabilities. To avoid zeros, a value of pseudocount/4 is first added to each position before normalization.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>freqs</code></strong> :&ensp;<code>np.array</code></dt>
<dd>array containing PFM values</dd>
<dt><strong><code>pseudocount</code></strong> :&ensp;<code>float</code></dt>
<dd>pseudocount to add</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Numpy array containing PPM.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pfm_to_ppm(freqs, pseudocount=0.1):
    &#34;&#34;&#34;Function to convert a valid PFM into a PPM. The matrix is normalized so that every position sums to 1, thus converting from a matrix of frequencies to a matrix of probabilities. To avoid zeros, a value of pseudocount/4 is first added to each position before normalization.

    Args:
        freqs (np.array): array containing PFM values
        pseudocount (float): pseudocount to add

    Returns:
        Numpy array containing PPM.

    &#34;&#34;&#34;
    check_pfm(freqs, warn=False)
    freqs = freqs + (pseudocount/4)
    return normalize_pm(freqs)</code></pre>
</details>
</dd>
<dt id="smeagol.matrices.position_wise_ic"><code class="name flex">
<span>def <span class="ident">position_wise_ic</span></span>(<span>probs)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to calculate the information content (IC) of each position in a PPM. The IC for a specific position is calculated using the formula: IC = 2 - sum(p*log2(p)), assuming a background probability of 0.25 for each of the 4 bases.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>probs</code></strong> :&ensp;<code>np.array</code></dt>
<dd>Numpy array containing PPM probability values. </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result (np.array): Numpy array containing the calculated information content of each column in probs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def position_wise_ic(probs):
    &#34;&#34;&#34;Function to calculate the information content (IC) of each position in a PPM. The IC for a specific position is calculated using the formula: IC = 2 - sum(p*log2(p)), assuming a background probability of 0.25 for each of the 4 bases.
 
    Args:
        probs (np.array): Numpy array containing PPM probability values. 

    Returns:
        result (np.array): Numpy array containing the calculated information content of each column in probs.

    &#34;&#34;&#34;
    check_ppm(probs)
    position_wise_entropy = np.apply_along_axis(entropy, axis=1, arr=probs)
    result = 2 - position_wise_entropy
    return result</code></pre>
</details>
</dd>
<dt id="smeagol.matrices.ppm_to_pwm"><code class="name flex">
<span>def <span class="ident">ppm_to_pwm</span></span>(<span>probs)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to convert a valid PPM into a PWM, using the formula: PWM = log2(PPM/B), where the background probability B is set to 0.25.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>probs</code></strong> :&ensp;<code>np.array</code></dt>
<dd>Numpy array containing PPM probability values</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Numpy array containing the PWM. The shape of this array is (L, 4) where L is the PWM length.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ppm_to_pwm(probs):
    &#34;&#34;&#34;Function to convert a valid PPM into a PWM, using the formula: PWM = log2(PPM/B), where the background probability B is set to 0.25.

    Args:
        probs (np.array): Numpy array containing PPM probability values

    Returns:
        Numpy array containing the PWM. The shape of this array is (L, 4) where L is the PWM length.

    &#34;&#34;&#34;
    check_ppm(probs)
    return np.log2(probs/0.25)</code></pre>
</details>
</dd>
<dt id="smeagol.matrices.pwm_to_ppm"><code class="name flex">
<span>def <span class="ident">pwm_to_ppm</span></span>(<span>weights)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pwm_to_ppm(weights):
    return np.exp2(weights)/4</code></pre>
</details>
</dd>
<dt id="smeagol.matrices.trim_ppm"><code class="name flex">
<span>def <span class="ident">trim_ppm</span></span>(<span>probs, frac_threshold)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to trim non-informative positions from the ends of a PPM. See <code><a title="smeagol.matrices.position_wise_ic" href="#smeagol.matrices.position_wise_ic">position_wise_ic()</a></code> for how information content of each position is calculated.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>probs</code></strong> :&ensp;<code>np.array</code></dt>
<dd>Numpy array containing PPM probability values</dd>
<dt><strong><code>frac_threshold</code></strong> :&ensp;<code>float</code></dt>
<dd>threshold between 0 and 1. The mean information content of all columns in
the matrix will be calculated and any continuous columns in the beginning and start
of the matrix that have information content less than frac_threshold * mean IC will
be dropped.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result (np.array): Numpy array containing trimmed PPM.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trim_ppm(probs, frac_threshold):
    &#34;&#34;&#34;Function to trim non-informative positions from the ends of a PPM. See `position_wise_ic` for how information content of each position is calculated.

    Args:
        probs (np.array): Numpy array containing PPM probability values
        frac_threshold (float): threshold between 0 and 1. The mean information content of all columns in
                                the matrix will be calculated and any continuous columns in the beginning and start
                                of the matrix that have information content less than frac_threshold * mean IC will
                                be dropped.

    Returns:
        result (np.array): Numpy array containing trimmed PPM.
    &#34;&#34;&#34;
    # Checks
    check_ppm(probs)
    assert (frac_threshold &gt;= 0) and (frac_threshold &lt;= 1)

    # Calculate information content
    pos_ic = position_wise_ic(probs)

    # Identify positions to trim
    to_trim = (pos_ic/np.mean(pos_ic)) &lt; frac_threshold
    positions = list(range(probs.shape[0]))
    assert len(to_trim) == len(positions)

    # Trim from start
    while to_trim[0]:
        positions = positions[1:]
        to_trim = to_trim[1:]

    # Trim from end
    while to_trim[-1]:
        positions = positions[:-1]
        to_trim = to_trim[:-1]

    result = probs[positions,:]
    return result</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="smeagol" href="index.html">smeagol</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="smeagol.matrices.align_pms" href="#smeagol.matrices.align_pms">align_pms</a></code></li>
<li><code><a title="smeagol.matrices.check_pfm" href="#smeagol.matrices.check_pfm">check_pfm</a></code></li>
<li><code><a title="smeagol.matrices.check_ppm" href="#smeagol.matrices.check_ppm">check_ppm</a></code></li>
<li><code><a title="smeagol.matrices.check_pwm" href="#smeagol.matrices.check_pwm">check_pwm</a></code></li>
<li><code><a title="smeagol.matrices.choose_cluster_representative_pms" href="#smeagol.matrices.choose_cluster_representative_pms">choose_cluster_representative_pms</a></code></li>
<li><code><a title="smeagol.matrices.choose_representative_pm" href="#smeagol.matrices.choose_representative_pm">choose_representative_pm</a></code></li>
<li><code><a title="smeagol.matrices.cluster_pms" href="#smeagol.matrices.cluster_pms">cluster_pms</a></code></li>
<li><code><a title="smeagol.matrices.cos_sim" href="#smeagol.matrices.cos_sim">cos_sim</a></code></li>
<li><code><a title="smeagol.matrices.entropy" href="#smeagol.matrices.entropy">entropy</a></code></li>
<li><code><a title="smeagol.matrices.matrix_correlation" href="#smeagol.matrices.matrix_correlation">matrix_correlation</a></code></li>
<li><code><a title="smeagol.matrices.ncorr" href="#smeagol.matrices.ncorr">ncorr</a></code></li>
<li><code><a title="smeagol.matrices.normalize_pm" href="#smeagol.matrices.normalize_pm">normalize_pm</a></code></li>
<li><code><a title="smeagol.matrices.order_pms" href="#smeagol.matrices.order_pms">order_pms</a></code></li>
<li><code><a title="smeagol.matrices.pairwise_ncorrs" href="#smeagol.matrices.pairwise_ncorrs">pairwise_ncorrs</a></code></li>
<li><code><a title="smeagol.matrices.pfm_to_ppm" href="#smeagol.matrices.pfm_to_ppm">pfm_to_ppm</a></code></li>
<li><code><a title="smeagol.matrices.position_wise_ic" href="#smeagol.matrices.position_wise_ic">position_wise_ic</a></code></li>
<li><code><a title="smeagol.matrices.ppm_to_pwm" href="#smeagol.matrices.ppm_to_pwm">ppm_to_pwm</a></code></li>
<li><code><a title="smeagol.matrices.pwm_to_ppm" href="#smeagol.matrices.pwm_to_ppm">pwm_to_ppm</a></code></li>
<li><code><a title="smeagol.matrices.trim_ppm" href="#smeagol.matrices.trim_ppm">trim_ppm</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>